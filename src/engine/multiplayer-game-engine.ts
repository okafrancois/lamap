"use client";

import {
  KoraGameEngine,
  type GameState,
  type GameAction,
  type PlayerEntity,
} from "./kora-game-engine";
import type { GameEvent, MultiplayerEventPayloads } from "@/types/multiplayer";
import { api } from "@/trpc/react";

export interface MultiplayerGameConfig {
  roomId: string;
  gameId: string;
  currentUserId: string;
  isHost: boolean;
}

export class MultiplayerGameEngine extends KoraGameEngine {
  private config: MultiplayerGameConfig;
  private pendingActions: GameAction[] = [];
  private lastEventTimestamp: Date = new Date();
  private eventPollingInterval?: NodeJS.Timeout;
  private onEventReceived?: (event: GameEvent) => void;

  // Injection des mutations tRPC (sera configur√© par le hook)
  private sendEventMutation?: any;
  private queryClient?: any;

  constructor(
    bet: number,
    maxRounds: number,
    players: PlayerEntity[],
    config: MultiplayerGameConfig,
  ) {
    super(bet, maxRounds, players);
    this.config = config;
  }

  // ========== CONFIGURATION ==========

  public setTRPCClient(sendEventMutation: any, queryClient: any) {
    this.sendEventMutation = sendEventMutation;
    this.queryClient = queryClient;
  }

  public setOnEventReceived(callback: (event: GameEvent) => void) {
    this.onEventReceived = callback;
  }

  // ========== OVERRIDE DES M√âTHODES PRINCIPALES ==========

  public playCard(cardId: string, player: PlayerEntity): boolean {
    // V√©rifier que c'est bien le joueur local qui joue
    if (player.username !== this.config.currentUserId) {
      console.warn("Tentative de jouer une carte pour un autre joueur");
      return false;
    }

    // Jouer la carte localement d'abord
    const success = super.playCard(cardId, player);

    if (success) {
      // Envoyer l'√©v√©nement aux autres joueurs
      this.sendGameEvent("CARD_PLAYED", {
        cardId,
        playerUsername: player.username,
      });
    }

    return success;
  }

  // M√©thode utilitaire pour jouer avec juste le username (pour les hooks)
  public playCardByUsername(cardId: string, playerUsername: string): boolean {
    const player = this.getPlayerByUsername(playerUsername);
    if (!player) {
      console.warn("Joueur introuvable:", playerUsername);
      return false;
    }
    return this.playCard(cardId, player);
  }

  public startNewGame(): void {
    // Seul l'h√¥te peut d√©marrer
    if (!this.config.isHost) {
      console.warn("Seul l'h√¥te peut d√©marrer la partie");
      return;
    }

    super.startNewGame();

    // Envoyer l'√©tat du jeu √† tous les joueurs
    this.sendGameEvent("GAME_START", {
      gameState: this.getState(),
    });
  }

  // ========== GESTION DES √âV√âNEMENTS ==========

  private async sendGameEvent<T extends keyof MultiplayerEventPayloads>(
    type: T,
    payload: MultiplayerEventPayloads[T],
  ): Promise<void> {
    if (!this.sendEventMutation) {
      console.error("tRPC client non configur√©");
      return;
    }

    try {
      await this.sendEventMutation.mutateAsync({
        roomId: this.config.roomId,
        gameId: this.config.gameId,
        type,
        payload,
      });

      console.log(`üì§ √âv√©nement envoy√©: ${type}`, payload);
    } catch (error) {
      console.error(`‚ùå Erreur envoi √©v√©nement ${type}:`, error);
    }
  }

  // Traiter un √©v√©nement re√ßu d'un autre joueur
  public processReceivedEvent(event: GameEvent): void {
    console.log(`üì• √âv√©nement re√ßu: ${event.type}`, event.payload);

    try {
      switch (event.type) {
        case "CARD_PLAYED":
          this.handleRemoteCardPlayed(event.payload);
          break;

        case "GAME_START":
          this.handleRemoteGameStarted(event.payload);
          break;

        case "GAME_STATE_UPDATE":
          this.handleRemoteStateUpdate(event.payload);
          break;

        case "TURN_CHANGE":
          this.handleRemoteTurnChange(event.payload);
          break;

        default:
          console.warn(`√âv√©nement non g√©r√©: ${event.type}`);
      }

      this.lastEventTimestamp = new Date(event.timestamp);

      // Callback pour les hooks
      if (this.onEventReceived) {
        this.onEventReceived(event);
      }
    } catch (error) {
      console.error(`‚ùå Erreur traitement √©v√©nement ${event.type}:`, error);
    }
  }

  private handleRemoteCardPlayed(payload: any): void {
    const { cardId, playerUsername } = payload;

    // Ne pas traiter ses propres actions
    if (playerUsername === this.config.currentUserId) {
      return;
    }

    // Trouver le joueur et appliquer l'action
    const player = this.getPlayerByUsername(playerUsername);
    if (player) {
      super.playCard(cardId, player);
    }
  }

  private handleRemoteGameStarted(payload: any): void {
    const { gameState } = payload;

    // Synchroniser l'√©tat de jeu
    this.setState(gameState);
  }

  private handleRemoteStateUpdate(payload: any): void {
    const { gameState } = payload;

    // Fusion intelligente des √©tats
    this.mergeGameState(gameState);
  }

  private handleRemoteTurnChange(payload: any): void {
    const { playerTurnUsername } = payload;

    // TODO: Impl√©menter la mise √† jour du tour
    // Pour l'instant, on laisse la synchronisation se faire via GAME_STATE_UPDATE
    console.log("Tour chang√© vers:", playerTurnUsername);
  }

  // ========== SYNCHRONISATION D'√âTAT ==========

  private setState(newState: GameState): void {
    // Utiliser loadState de la classe de base
    this.loadState(newState);
  }

  private mergeGameState(remoteState: GameState): void {
    // Logique de fusion intelligente pour √©viter les conflits
    const currentState = this.getState();

    // Toujours prendre la version la plus r√©cente
    if (remoteState.version > currentState.version) {
      console.log(
        `üîÑ Sync state: v${currentState.version} ‚Üí v${remoteState.version}`,
      );

      // Pr√©server certaines donn√©es locales importantes
      const localPlayerData = currentState.players.find(
        (p) => p.username === this.config.currentUserId,
      );

      const newState = { ...remoteState };

      // Restaurer les donn√©es locales si n√©cessaire
      if (localPlayerData) {
        const playerIndex = newState.players.findIndex(
          (p) => p.username === this.config.currentUserId,
        );
        if (playerIndex !== -1 && newState.players[playerIndex]) {
          const currentPlayer = newState.players[playerIndex];
          newState.players[playerIndex] = {
            ...currentPlayer,
            hand: localPlayerData.hand, // Garder la main locale
            isThinking: localPlayerData.isThinking ?? false,
          };
        }
      }

      this.loadState(newState);
    }
  }

  // ========== POLLING DES √âV√âNEMENTS ==========

  public startEventPolling(intervalMs = 1000): void {
    this.stopEventPolling();

    this.eventPollingInterval = setInterval(() => {
      this.pollForEvents();
    }, intervalMs);

    console.log(`üîÑ Event polling d√©marr√© (${intervalMs}ms)`);
  }

  public stopEventPolling(): void {
    if (this.eventPollingInterval) {
      clearInterval(this.eventPollingInterval);
      this.eventPollingInterval = undefined;
      console.log("‚èπÔ∏è Event polling arr√™t√©");
    }
  }

  private async pollForEvents(): Promise<void> {
    if (!this.queryClient) return;

    try {
      // Cette logique sera impl√©ment√©e avec le hook correspondant
      // qui utilisera getRoomUpdates pour r√©cup√©rer les nouveaux √©v√©nements
    } catch (error) {
      console.error("‚ùå Erreur polling √©v√©nements:", error);
    }
  }

  // ========== UTILITAIRES ==========

  public isLocalPlayer(playerUsername: string): boolean {
    return playerUsername === this.config.currentUserId;
  }

  public getLocalPlayer(): PlayerEntity | null {
    return (
      this.getState().players.find(
        (p) => p.username === this.config.currentUserId,
      ) ?? null
    );
  }

  public isMyTurn(): boolean {
    return this.getState().playerTurnUsername === this.config.currentUserId;
  }

  public getConfig(): MultiplayerGameConfig {
    return { ...this.config };
  }

  // ========== CLEANUP ==========

  public destroy(): void {
    this.stopEventPolling();
    this.pendingActions = [];
    // Note: listeners est g√©r√© par la classe de base
  }

  // ========== UTILITAIRES ==========

  private sendPeriodicStateSync(): void {
    // Envoyer un sync d'√©tat toutes les 30 secondes si on est l'h√¥te
    const now = Date.now();
    const lastSync = (this as any).lastStateSyncTime ?? 0;

    if (now - lastSync > 30000) {
      // 30 secondes
      this.sendGameEvent("GAME_STATE_UPDATE", {
        gameState: this.getState(),
      });
      (this as any).lastStateSyncTime = now;
    }
  }
}
